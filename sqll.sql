create table public.tbl_owner (
  owner_uid serial not null,
  owner_name character varying(50) not null,
  owner_email character varying(150) not null,
  owner_password character varying(100) not null,
  created_at timestamp without time zone null default CURRENT_TIMESTAMP,
  updated_at timestamp without time zone null default CURRENT_TIMESTAMP,
  auth_user_id uuid null,
  constraint tbl_owner_pkey primary key (owner_uid),
  constraint tbl_owner_owner_email_key unique (owner_email)
) TABLESPACE pg_default;

create table public.tbl_admin (
  admin_id bigint generated by default as identity not null,
  admin_name character varying not null,
  admin_password character varying null,
  created_at timestamp with time zone not null default now(),
  constraint tbl_admin_pkey primary key (admin_id)
) TABLESPACE pg_default;

create table public.profiles (
  username text not null,
  useremail text not null,
  userage integer null,
  usertel text null,
  profile_image text null,
  full_name text null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  user_uid uuid not null,
  constraint profiles_pkey primary key (user_uid),
  constraint profiles_user_uid_key unique (user_uid),
  constraint profiles_useremail_key unique (useremail),
  constraint profiles_username_key unique (username),
  constraint profiles_user_uid_fkey foreign KEY (user_uid) references auth.users (id),
  constraint profiles_userage_check check (
    (
      (userage >= 10)
      and (userage <= 100)
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_profiles_useremail on public.profiles using btree (useremail) TABLESPACE pg_default;

create index IF not exists idx_profiles_username on public.profiles using btree (username) TABLESPACE pg_default;

create trigger update_profiles_updated_at BEFORE
update on profiles for EACH row
execute FUNCTION update_updated_at_column ();

create table public.booking_history (
  history_id uuid not null default gen_random_uuid (),
  booking_id uuid null,
  from_status character varying(20) null,
  to_status character varying(20) null,
  change_reason text null,
  changed_by uuid null,
  created_at timestamp with time zone null default now(),
  constraint booking_history_pkey primary key (history_id),
  constraint booking_history_booking_id_fkey foreign KEY (booking_id) references bookings (booking_id) on delete CASCADE,
  constraint booking_history_changed_by_fkey foreign KEY (changed_by) references auth.users (id)
) TABLESPACE pg_default;

create table public.bookings (
  booking_id uuid not null default gen_random_uuid (),
  user_id uuid null,
  fitness_id integer null,
  owner_uid integer null,
  booking_date date not null,
  booking_time timestamp with time zone null default now(),
  total_amount numeric(10, 2) not null,
  booking_status character varying(20) null default 'pending'::character varying,
  notes text null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint bookings_pkey primary key (booking_id),
  constraint bookings_fitness_id_fkey foreign KEY (fitness_id) references tbl_fitness (fit_id) on delete CASCADE,
  constraint bookings_owner_uid_fkey foreign KEY (owner_uid) references tbl_owner (owner_uid) on delete CASCADE,
  constraint bookings_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE,
  constraint bookings_booking_status_check check (
    (
      (booking_status)::text = any (
        (
          array[
            'pending'::character varying,
            'confirmed'::character varying,
            'cancelled'::character varying,
            'completed'::character varying,
            'expired'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_bookings_user_id on public.bookings using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_bookings_fitness_id on public.bookings using btree (fitness_id) TABLESPACE pg_default;

create index IF not exists idx_bookings_booking_date on public.bookings using btree (booking_date) TABLESPACE pg_default;

create index IF not exists idx_bookings_status on public.bookings using btree (booking_status) TABLESPACE pg_default;

create trigger update_bookings_updated_at BEFORE
update on bookings for EACH row
execute FUNCTION update_updated_at_column ();

create table public.fitness_images (
  id bigserial not null,
  fitness_id bigint not null,
  image_path text not null,
  image_url text null,
  position integer null default 0,
  created_by uuid null,
  created_at timestamp with time zone null default now(),
  constraint fitness_images_pkey primary key (id),
  constraint fitness_images_created_by_fkey foreign KEY (created_by) references auth.users (id) on delete set null,
  constraint fitness_images_fitness_fk foreign KEY (fitness_id) references tbl_fitness (fit_id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_fitness_images_fitness_id on public.fitness_images using btree (fitness_id) TABLESPACE pg_default;

create index IF not exists idx_fitness_images_position on public.fitness_images using btree (fitness_id, "position") TABLESPACE pg_default;

create table public.payment_splits (
  split_id uuid not null default gen_random_uuid (),
  payment_id uuid null,
  system_split_amount numeric(10, 2) not null,
  system_split_status character varying(20) null default 'pending'::character varying,
  fitness_split_amount numeric(10, 2) not null,
  fitness_split_status character varying(20) null default 'pending'::character varying,
  fitness_transfer_ref character varying(255) null,
  system_fee_ref character varying(255) null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint payment_splits_pkey primary key (split_id),
  constraint payment_splits_payment_id_fkey foreign KEY (payment_id) references payments (payment_id) on delete CASCADE,
  constraint payment_splits_fitness_split_status_check check (
    (
      (fitness_split_status)::text = any (
        (
          array[
            'pending'::character varying,
            'completed'::character varying,
            'failed'::character varying
          ]
        )::text[]
      )
    )
  ),
  constraint payment_splits_system_split_status_check check (
    (
      (system_split_status)::text = any (
        (
          array[
            'pending'::character varying,
            'completed'::character varying,
            'failed'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_payment_splits_payment_id on public.payment_splits using btree (payment_id) TABLESPACE pg_default;

create trigger update_payment_splits_updated_at BEFORE
update on payment_splits for EACH row
execute FUNCTION update_updated_at_column ();

create table public.payment_splits (
  split_id uuid not null default gen_random_uuid (),
  payment_id uuid null,
  system_split_amount numeric(10, 2) not null,
  system_split_status character varying(20) null default 'pending'::character varying,
  fitness_split_amount numeric(10, 2) not null,
  fitness_split_status character varying(20) null default 'pending'::character varying,
  fitness_transfer_ref character varying(255) null,
  system_fee_ref character varying(255) null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint payment_splits_pkey primary key (split_id),
  constraint payment_splits_payment_id_fkey foreign KEY (payment_id) references payments (payment_id) on delete CASCADE,
  constraint payment_splits_fitness_split_status_check check (
    (
      (fitness_split_status)::text = any (
        (
          array[
            'pending'::character varying,
            'completed'::character varying,
            'failed'::character varying
          ]
        )::text[]
      )
    )
  ),
  constraint payment_splits_system_split_status_check check (
    (
      (system_split_status)::text = any (
        (
          array[
            'pending'::character varying,
            'completed'::character varying,
            'failed'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_payment_splits_payment_id on public.payment_splits using btree (payment_id) TABLESPACE pg_default;

create trigger update_payment_splits_updated_at BEFORE
update on payment_splits for EACH row
execute FUNCTION update_updated_at_column ();

create table public.refunds (
  refund_id uuid not null default gen_random_uuid (),
  payment_id uuid null,
  booking_id uuid null,
  refund_amount numeric(10, 2) not null,
  refund_reason text null,
  refund_status character varying(20) null default 'pending'::character varying,
  refund_reference character varying(255) null,
  processed_at timestamp with time zone null,
  created_at timestamp with time zone null default now(),
  constraint refunds_pkey primary key (refund_id),
  constraint refunds_booking_id_fkey foreign KEY (booking_id) references bookings (booking_id) on delete CASCADE,
  constraint refunds_payment_id_fkey foreign KEY (payment_id) references payments (payment_id) on delete CASCADE,
  constraint refunds_refund_status_check check (
    (
      (refund_status)::text = any (
        (
          array[
            'pending'::character varying,
            'processing'::character varying,
            'completed'::character varying,
            'failed'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;

create table public.refunds (
  refund_id uuid not null default gen_random_uuid (),
  payment_id uuid null,
  booking_id uuid null,
  refund_amount numeric(10, 2) not null,
  refund_reason text null,
  refund_status character varying(20) null default 'pending'::character varying,
  refund_reference character varying(255) null,
  processed_at timestamp with time zone null,
  created_at timestamp with time zone null default now(),
  constraint refunds_pkey primary key (refund_id),
  constraint refunds_booking_id_fkey foreign KEY (booking_id) references bookings (booking_id) on delete CASCADE,
  constraint refunds_payment_id_fkey foreign KEY (payment_id) references payments (payment_id) on delete CASCADE,
  constraint refunds_refund_status_check check (
    (
      (refund_status)::text = any (
        (
          array[
            'pending'::character varying,
            'processing'::character varying,
            'completed'::character varying,
            'failed'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;

create table public.tbl_favorites (
  favorite_id uuid not null default gen_random_uuid (),
  user_id uuid not null,
  fitness_id integer not null,
  created_at timestamp with time zone not null default now(),
  constraint tbl_favorites_pkey primary key (favorite_id),
  constraint tbl_favorites_fitness_id_fkey foreign KEY (fitness_id) references tbl_fitness (fit_id) on delete CASCADE,
  constraint tbl_favorites_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_tbl_favorites_fitness_id on public.tbl_favorites using btree (fitness_id) TABLESPACE pg_default;

create trigger trg_set_favorite_user BEFORE INSERT on tbl_favorites for EACH row
execute FUNCTION set_favorite_user ();

create table public.tbl_favorites (
  favorite_id uuid not null default gen_random_uuid (),
  user_id uuid not null,
  fitness_id integer not null,
  created_at timestamp with time zone not null default now(),
  constraint tbl_favorites_pkey primary key (favorite_id),
  constraint tbl_favorites_fitness_id_fkey foreign KEY (fitness_id) references tbl_fitness (fit_id) on delete CASCADE,
  constraint tbl_favorites_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_tbl_favorites_fitness_id on public.tbl_favorites using btree (fitness_id) TABLESPACE pg_default;

create trigger trg_set_favorite_user BEFORE INSERT on tbl_favorites for EACH row
execute FUNCTION set_favorite_user ();

create table public.tbl_favorites (
  favorite_id uuid not null default gen_random_uuid (),
  user_id uuid not null,
  fitness_id integer not null,
  created_at timestamp with time zone not null default now(),
  constraint tbl_favorites_pkey primary key (favorite_id),
  constraint tbl_favorites_fitness_id_fkey foreign KEY (fitness_id) references tbl_fitness (fit_id) on delete CASCADE,
  constraint tbl_favorites_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_tbl_favorites_fitness_id on public.tbl_favorites using btree (fitness_id) TABLESPACE pg_default;

create trigger trg_set_favorite_user BEFORE INSERT on tbl_favorites for EACH row
execute FUNCTION set_favorite_user ();

create table public.tbl_favorites (
  favorite_id uuid not null default gen_random_uuid (),
  user_id uuid not null,
  fitness_id integer not null,
  created_at timestamp with time zone not null default now(),
  constraint tbl_favorites_pkey primary key (favorite_id),
  constraint tbl_favorites_fitness_id_fkey foreign KEY (fitness_id) references tbl_fitness (fit_id) on delete CASCADE,
  constraint tbl_favorites_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_tbl_favorites_fitness_id on public.tbl_favorites using btree (fitness_id) TABLESPACE pg_default;

create trigger trg_set_favorite_user BEFORE INSERT on tbl_favorites for EACH row
execute FUNCTION set_favorite_user ();