create table public.tbl_owner (
  owner_uid serial not null,
  owner_name character varying(50) not null,
  owner_email character varying(150) not null,
  owner_password character varying(100) not null,
  created_at timestamp without time zone null default CURRENT_TIMESTAMP,
  updated_at timestamp without time zone null default CURRENT_TIMESTAMP,
  auth_user_id uuid null,
  constraint tbl_owner_pkey primary key (owner_uid),
  constraint tbl_owner_owner_email_key unique (owner_email)
) TABLESPACE pg_default;

create table public.tbl_admin (
  admin_id bigint generated by default as identity not null,
  admin_name character varying not null,
  admin_password character varying null,
  created_at timestamp with time zone not null default now(),
  constraint tbl_admin_pkey primary key (admin_id)
) TABLESPACE pg_default;

create table public.profiles (
  username text not null,
  useremail text not null,
  userage integer null,
  usertel text null,
  profile_image text null,
  full_name text null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  user_uid uuid not null,
  constraint profiles_pkey primary key (user_uid),
  constraint profiles_user_uid_key unique (user_uid),
  constraint profiles_useremail_key unique (useremail),
  constraint profiles_username_key unique (username),
  constraint profiles_user_uid_fkey foreign KEY (user_uid) references auth.users (id),
  constraint profiles_userage_check check (
    (
      (userage >= 10)
      and (userage <= 100)
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_profiles_useremail on public.profiles using btree (useremail) TABLESPACE pg_default;

create index IF not exists idx_profiles_username on public.profiles using btree (username) TABLESPACE pg_default;

create trigger update_profiles_updated_at BEFORE
update on profiles for EACH row
execute FUNCTION update_updated_at_column ();

create table public.booking_history (
  history_id uuid not null default gen_random_uuid (),
  booking_id uuid null,
  from_status character varying(20) null,
  to_status character varying(20) null,
  change_reason text null,
  changed_by uuid null,
  created_at timestamp with time zone null default now(),
  constraint booking_history_pkey primary key (history_id),
  constraint booking_history_booking_id_fkey foreign KEY (booking_id) references bookings (booking_id) on delete CASCADE,
  constraint booking_history_changed_by_fkey foreign KEY (changed_by) references auth.users (id)
) TABLESPACE pg_default;

create table public.bookings (
  booking_id uuid not null default gen_random_uuid (),
  user_id uuid null,
  fitness_id integer null,
  owner_uid integer null,
  booking_date date not null,
  booking_time timestamp with time zone null default now(),
  total_amount numeric(10, 2) not null,
  booking_status character varying(20) null default 'pending'::character varying,
  notes text null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint bookings_pkey primary key (booking_id),
  constraint bookings_fitness_id_fkey foreign KEY (fitness_id) references tbl_fitness (fit_id) on delete CASCADE,
  constraint bookings_owner_uid_fkey foreign KEY (owner_uid) references tbl_owner (owner_uid) on delete CASCADE,
  constraint bookings_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE,
  constraint bookings_booking_status_check check (
    (
      (booking_status)::text = any (
        (
          array[
            'pending'::character varying,
            'confirmed'::character varying,
            'cancelled'::character varying,
            'completed'::character varying,
            'expired'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_bookings_user_id on public.bookings using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_bookings_fitness_id on public.bookings using btree (fitness_id) TABLESPACE pg_default;

create index IF not exists idx_bookings_booking_date on public.bookings using btree (booking_date) TABLESPACE pg_default;

create index IF not exists idx_bookings_status on public.bookings using btree (booking_status) TABLESPACE pg_default;

create trigger update_bookings_updated_at BEFORE
update on bookings for EACH row
execute FUNCTION update_updated_at_column ();

create table public.fitness_images (
  id bigserial not null,
  fitness_id bigint not null,
  image_path text not null,
  image_url text null,
  position integer null default 0,
  created_by uuid null,
  created_at timestamp with time zone null default now(),
  constraint fitness_images_pkey primary key (id),
  constraint fitness_images_created_by_fkey foreign KEY (created_by) references auth.users (id) on delete set null,
  constraint fitness_images_fitness_fk foreign KEY (fitness_id) references tbl_fitness (fit_id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_fitness_images_fitness_id on public.fitness_images using btree (fitness_id) TABLESPACE pg_default;

create index IF not exists idx_fitness_images_position on public.fitness_images using btree (fitness_id, "position") TABLESPACE pg_default;

create table public.payment_splits (
  split_id uuid not null default gen_random_uuid (),
  payment_id uuid null,
  system_split_amount numeric(10, 2) not null,
  system_split_status character varying(20) null default 'pending'::character varying,
  fitness_split_amount numeric(10, 2) not null,
  fitness_split_status character varying(20) null default 'pending'::character varying,
  fitness_transfer_ref character varying(255) null,
  system_fee_ref character varying(255) null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint payment_splits_pkey primary key (split_id),
  constraint payment_splits_payment_id_fkey foreign KEY (payment_id) references payments (payment_id) on delete CASCADE,
  constraint payment_splits_fitness_split_status_check check (
    (
      (fitness_split_status)::text = any (
        (
          array[
            'pending'::character varying,
            'completed'::character varying,
            'failed'::character varying
          ]
        )::text[]
      )
    )
  ),
  constraint payment_splits_system_split_status_check check (
    (
      (system_split_status)::text = any (
        (
          array[
            'pending'::character varying,
            'completed'::character varying,
            'failed'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_payment_splits_payment_id on public.payment_splits using btree (payment_id) TABLESPACE pg_default;

create trigger update_payment_splits_updated_at BEFORE
update on payment_splits for EACH row
execute FUNCTION update_updated_at_column ();



create table public.refunds (
  refund_id uuid not null default gen_random_uuid (),
  payment_id uuid null,
  booking_id uuid null,
  refund_amount numeric(10, 2) not null,
  refund_reason text null,
  refund_status character varying(20) null default 'pending'::character varying,
  refund_reference character varying(255) null,
  processed_at timestamp with time zone null,
  created_at timestamp with time zone null default now(),
  constraint refunds_pkey primary key (refund_id),
  constraint refunds_booking_id_fkey foreign KEY (booking_id) references bookings (booking_id) on delete CASCADE,
  constraint refunds_payment_id_fkey foreign KEY (payment_id) references payments (payment_id) on delete CASCADE,
  constraint refunds_refund_status_check check (
    (
      (refund_status)::text = any (
        (
          array[
            'pending'::character varying,
            'processing'::character varying,
            'completed'::character varying,
            'failed'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;



create table public.tbl_favorites (
  favorite_id uuid not null default gen_random_uuid (),
  user_id uuid not null,
  fitness_id integer not null,
  created_at timestamp with time zone not null default now(),
  constraint tbl_favorites_pkey primary key (favorite_id),
  constraint tbl_favorites_fitness_id_fkey foreign KEY (fitness_id) references tbl_fitness (fit_id) on delete CASCADE,
  constraint tbl_favorites_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_tbl_favorites_fitness_id on public.tbl_favorites using btree (fitness_id) TABLESPACE pg_default;

create trigger trg_set_favorite_user BEFORE INSERT on tbl_favorites for EACH row
execute FUNCTION set_favorite_user ();

create table public.payments (
  payment_id uuid not null default gen_random_uuid (),
  booking_id uuid null,
  user_id uuid null,
  total_amount numeric(10, 2) not null,
  system_fee numeric(10, 2) not null,
  fitness_amount numeric(10, 2) not null,
  payment_method character varying(50) null default 'credit_card'::character varying,
  payment_status character varying(20) null default 'pending'::character varying,
  transaction_id character varying(255) null,
  gateway_response jsonb null,
  gateway_reference character varying(255) null,
  paid_at timestamp with time zone null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint payments_pkey primary key (payment_id),
  constraint payments_transaction_id_key unique (transaction_id),
  constraint payments_booking_id_fkey foreign KEY (booking_id) references bookings (booking_id) on delete CASCADE,
  constraint payments_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE,
  constraint payments_payment_method_check check (
    (
      (payment_method)::text = any (
        (
          array[
            'credit_card'::character varying,
            'debit_card'::character varying,
            'promptpay'::character varying,
            'bank_transfer'::character varying,
            'wallet'::character varying
          ]
        )::text[]
      )
    )
  ),
  constraint payments_payment_status_check check (
    (
      (payment_status)::text = any (
        (
          array[
            'pending'::character varying,
            'processing'::character varying,
            'completed'::character varying,
            'failed'::character varying,
            'refunded'::character varying,
            'cancelled'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_payments_booking_id on public.payments using btree (booking_id) TABLESPACE pg_default;

create index IF not exists idx_payments_user_id on public.payments using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_payments_status on public.payments using btree (payment_status) TABLESPACE pg_default;

create index IF not exists idx_payments_transaction_id on public.payments using btree (transaction_id) TABLESPACE pg_default;

create trigger update_payments_updated_at BEFORE
update on payments for EACH row
execute FUNCTION update_updated_at_column ();

create table public.tbl_classes (
  class_id serial not null,
  fit_id integer null,
  class_name character varying(255) not null,
  description text null,
  image_url text null,
  class_time time without time zone null,
  duration integer null default 60,
  instructor character varying(255) null,
  max_participants integer null default 10,
  price numeric(10, 2) null default 0,
  status character varying(20) null default 'active'::character varying,
  created_at timestamp with time zone null default CURRENT_TIMESTAMP,
  updated_at timestamp with time zone null default CURRENT_TIMESTAMP,
  constraint tbl_classes_pkey primary key (class_id),
  constraint tbl_classes_fit_id_fkey foreign KEY (fit_id) references tbl_fitness (fit_id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_classes_fit_id on public.tbl_classes using btree (fit_id) TABLESPACE pg_default;

create index IF not exists idx_classes_status on public.tbl_classes using btree (status) TABLESPACE pg_default;

create trigger update_tbl_classes_updated_at BEFORE
update on tbl_classes for EACH row
execute FUNCTION update_updated_at_column ();

create table public.tbl_fitness (
  fit_id serial not null,
  fit_name character varying(200) not null,
  fit_user character varying(100) not null,
  fit_price character varying(50) not null,
  fit_image text not null,
  fit_address text not null,
  fit_contact character varying(200) not null,
  fit_dateclose time without time zone not null,
  fit_dateopen time without time zone not null,
  fit_location text not null,
  fit_moredetails text not null,
  fit_phone character varying(50) not null,
  created_at timestamp without time zone null default CURRENT_TIMESTAMP,
  updated_at timestamp without time zone null default CURRENT_TIMESTAMP,
  created_by uuid null,
  fit_image2 text null,
  fit_image3 text null,
  fit_image4 text null,
  fit_price_memberm numeric(10, 2) null default 0,
  fit_price_membery numeric(10, 2) null default 0,
  partner_bank_account character varying(20) null,
  partner_bank_name character varying(100) null,
  partner_account_name character varying(100) null,
  partner_promptpay_id character varying(20) null,
  revenue_split_percentage numeric(5, 2) null default 80.00,
  constraint tbl_fitness_pkey primary key (fit_id)
) TABLESPACE pg_default;

create index IF not exists idx_tbl_fitness_memberm_price on public.tbl_fitness using btree (fit_price_memberm) TABLESPACE pg_default;

create index IF not exists idx_tbl_fitness_membery_price on public.tbl_fitness using btree (fit_price_membery) TABLESPACE pg_default;


create table public.tbl_class_enrollments (
  enrollment_id uuid not null default gen_random_uuid (),
  user_id uuid not null,
  class_id integer not null,
  fitness_id integer not null,
  enrollment_date date not null default CURRENT_DATE,
  status character varying(20) null default 'enrolled'::character varying,
  payment_id uuid null,
  created_at timestamp with time zone null default CURRENT_TIMESTAMP,
  updated_at timestamp with time zone null default CURRENT_TIMESTAMP,
  constraint tbl_class_enrollments_pkey primary key (enrollment_id),
  constraint tbl_class_enrollments_class_id_fkey foreign KEY (class_id) references tbl_classes (class_id) on delete CASCADE,
  constraint tbl_class_enrollments_fitness_id_fkey foreign KEY (fitness_id) references tbl_fitness (fit_id) on delete CASCADE,
  constraint tbl_class_enrollments_payment_id_fkey foreign KEY (payment_id) references payments (payment_id) on delete set null,
  constraint tbl_class_enrollments_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE,
  constraint tbl_class_enrollments_status_check check (
    (
      (status)::text = any (
        (
          array[
            'enrolled'::character varying,
            'completed'::character varying,
            'cancelled'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_class_enrollments_user_id on public.tbl_class_enrollments using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_class_enrollments_class_id on public.tbl_class_enrollments using btree (class_id) TABLESPACE pg_default;

create index IF not exists idx_class_enrollments_fitness_id on public.tbl_class_enrollments using btree (fitness_id) TABLESPACE pg_default;

create index IF not exists idx_class_enrollments_status on public.tbl_class_enrollments using btree (status) TABLESPACE pg_default;

create trigger update_class_enrollments_updated_at BEFORE
update on tbl_class_enrollments for EACH row
execute FUNCTION update_updated_at_column ();

create table public.tbl_memberships (
  membership_id uuid not null default gen_random_uuid (),
  user_id uuid not null,
  fitness_id integer not null,
  membership_type character varying(20) not null,
  amount numeric(10, 2) not null,
  start_date date not null default CURRENT_DATE,
  end_date date not null,
  status character varying(20) null default 'active'::character varying,
  payment_id uuid null,
  created_at timestamp with time zone null default CURRENT_TIMESTAMP,
  updated_at timestamp with time zone null default CURRENT_TIMESTAMP,
  constraint tbl_memberships_pkey primary key (membership_id),
  constraint tbl_memberships_fitness_id_fkey foreign KEY (fitness_id) references tbl_fitness (fit_id) on delete CASCADE,
  constraint tbl_memberships_payment_id_fkey foreign KEY (payment_id) references payments (payment_id) on delete set null,
  constraint tbl_memberships_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE,
  constraint tbl_memberships_membership_type_check check (
    (
      (membership_type)::text = any (
        (
          array[
            'monthly'::character varying,
            'yearly'::character varying
          ]
        )::text[]
      )
    )
  ),
  constraint tbl_memberships_status_check check (
    (
      (status)::text = any (
        (
          array[
            'active'::character varying,
            'expired'::character varying,
            'cancelled'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_memberships_user_id on public.tbl_memberships using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_memberships_fitness_id on public.tbl_memberships using btree (fitness_id) TABLESPACE pg_default;

create index IF not exists idx_memberships_status on public.tbl_memberships using btree (status) TABLESPACE pg_default;

create index IF not exists idx_memberships_dates on public.tbl_memberships using btree (start_date, end_date) TABLESPACE pg_default;

create trigger update_memberships_updated_at BEFORE
update on tbl_memberships for EACH row
execute FUNCTION update_updated_at_column ();

create table public.qr_payments (
  qr_payment_id uuid not null default gen_random_uuid (),
  transaction_id text not null,
  user_id uuid null,
  qr_code text not null,
  qr_image_url text null,
  amount numeric(10, 2) not null,
  currency character varying(3) null default 'THB'::character varying,
  status character varying(20) null default 'pending'::character varying,
  payment_method character varying(50) null default 'qr_promptpay'::character varying,
  expires_at timestamp with time zone not null,
  paid_at timestamp with time zone null,
  cancelled_at timestamp with time zone null,
  gateway_response jsonb null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint qr_payments_pkey primary key (qr_payment_id),
  constraint qr_payments_transaction_id_key unique (transaction_id),
  constraint qr_payments_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE,
  constraint qr_payments_status_check check (
    (
      (status)::text = any (
        (
          array[
            'pending'::character varying,
            'success'::character varying,
            'failed'::character varying,
            'expired'::character varying,
            'cancelled'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_qr_payments_transaction_id on public.qr_payments using btree (transaction_id) TABLESPACE pg_default;

create index IF not exists idx_qr_payments_user_id on public.qr_payments using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_qr_payments_status on public.qr_payments using btree (status) TABLESPACE pg_default;

create index IF not exists idx_qr_payments_expires_at on public.qr_payments using btree (expires_at) TABLESPACE pg_default;

create trigger trigger_update_qr_payments_updated_at BEFORE
update on qr_payments for EACH row
execute FUNCTION update_qr_payments_updated_at ();

create table public.tbl_equipment (
  em_id serial not null,
  em_name character varying(100) not null,
  em_image character varying(255) null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  fitness_id integer not null,
  created_by uuid null,
  constraint tbl_equipment_pkey primary key (em_id),
  constraint tbl_equipment_created_by_fkey foreign KEY (created_by) references auth.users (id),
  constraint tbl_equipment_fitness_id_fkey foreign KEY (fitness_id) references tbl_fitness (fit_id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_tbl_equipment_fitness_id on public.tbl_equipment using btree (fitness_id) TABLESPACE pg_default;

create index IF not exists idx_tbl_equipment_created_by on public.tbl_equipment using btree (created_by) TABLESPACE pg_default;

create trigger trg_set_created_by_equipment BEFORE INSERT on tbl_equipment for EACH row
execute FUNCTION set_created_by_equipment ();


create table public.tbl_favorites (
  favorite_id uuid not null default gen_random_uuid (),
  user_id uuid not null,
  fitness_id integer not null,
  created_at timestamp with time zone not null default now(),
  constraint tbl_favorites_pkey primary key (favorite_id),
  constraint tbl_favorites_fitness_id_fkey foreign KEY (fitness_id) references tbl_fitness (fit_id) on delete CASCADE,
  constraint tbl_favorites_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_tbl_favorites_fitness_id on public.tbl_favorites using btree (fitness_id) TABLESPACE pg_default;

create trigger trg_set_favorite_user BEFORE INSERT on tbl_favorites for EACH row
execute FUNCTION set_favorite_user ();

create table public.tbl_fitness_requests (
  id uuid not null default gen_random_uuid (),
  fit_name character varying(255) not null,
  fit_type character varying(100) null,
  fit_description text null,
  fit_price numeric(10, 2) null,
  fit_duration integer null,
  fit_location character varying(500) null,
  fit_contact character varying(255) null,
  fit_image text null,
  owner_id integer null,
  status character varying(50) null default 'pending'::character varying,
  approved_at timestamp with time zone null,
  approved_by integer null,
  rejected_at timestamp with time zone null,
  rejected_by integer null,
  rejection_reason text null,
  created_at timestamp with time zone null default CURRENT_TIMESTAMP,
  updated_at timestamp with time zone null default CURRENT_TIMESTAMP,
  constraint tbl_fitness_requests_pkey primary key (id),
  constraint tbl_fitness_requests_approved_by_fkey foreign KEY (approved_by) references tbl_admin (admin_id),
  constraint tbl_fitness_requests_owner_id_fkey foreign KEY (owner_id) references tbl_owner (owner_uid) on delete CASCADE,
  constraint tbl_fitness_requests_rejected_by_fkey foreign KEY (rejected_by) references tbl_admin (admin_id)
) TABLESPACE pg_default;

create index IF not exists idx_fitness_requests_owner_id on public.tbl_fitness_requests using btree (owner_id) TABLESPACE pg_default;

create index IF not exists idx_fitness_requests_status on public.tbl_fitness_requests using btree (status) TABLESPACE pg_default;

create index IF not exists idx_fitness_requests_created_at on public.tbl_fitness_requests using btree (created_at) TABLESPACE pg_default;

create trigger update_fitness_requests_updated_at BEFORE
update on tbl_fitness_requests for EACH row
execute FUNCTION update_updated_at_column ();


create table public.tbl_reviews (
  id uuid not null default gen_random_uuid (),
  user_id uuid not null,
  fitness_id integer not null,
  rating integer not null,
  comment text null,
  created_at timestamp with time zone not null default timezone ('utc'::text, now()),
  updated_at timestamp with time zone not null default timezone ('utc'::text, now()),
  constraint tbl_reviews_pkey primary key (id),
  constraint tbl_reviews_user_id_fitness_id_key unique (user_id, fitness_id),
  constraint tbl_reviews_fitness_id_fkey foreign KEY (fitness_id) references tbl_fitness (fit_id) on delete CASCADE,
  constraint tbl_reviews_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE,
  constraint tbl_reviews_rating_check check (
    (
      (rating >= 1)
      and (rating <= 5)
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_reviews_fitness_id on public.tbl_reviews using btree (fitness_id) TABLESPACE pg_default;

create index IF not exists idx_reviews_user_id on public.tbl_reviews using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_reviews_rating on public.tbl_reviews using btree (rating) TABLESPACE pg_default;

create index IF not exists idx_reviews_created_at on public.tbl_reviews using btree (created_at) TABLESPACE pg_default;

create trigger update_tbl_reviews_updated_at BEFORE
update on tbl_reviews for EACH row
execute FUNCTION update_updated_at_column ();

create table public.tbl_fitness (
  fit_id serial not null,
  fit_name character varying(200) not null,
  fit_user character varying(100) not null,
  fit_price character varying(50) not null,
  fit_image text not null,
  fit_address text not null,
  fit_contact character varying(200) not null,
  fit_dateclose time without time zone not null,
  fit_dateopen time without time zone not null,
  fit_location text not null,
  fit_moredetails text not null,
  fit_phone character varying(50) not null,
  created_at timestamp without time zone null default CURRENT_TIMESTAMP,
  updated_at timestamp without time zone null default CURRENT_TIMESTAMP,
  created_by uuid null,
  fit_image2 text null,
  fit_image3 text null,
  fit_image4 text null,
  fit_price_memberm numeric(10, 2) null default 0,
  fit_price_membery numeric(10, 2) null default 0,
  partner_bank_account character varying(20) null,
  partner_bank_name character varying(100) null,
  partner_account_name character varying(100) null,
  partner_promptpay_id character varying(20) null,
  revenue_split_percentage numeric(5, 2) null default 80.00,
  constraint tbl_fitness_pkey primary key (fit_id)
) TABLESPACE pg_default;

create index IF not exists idx_tbl_fitness_memberm_price on public.tbl_fitness using btree (fit_price_memberm) TABLESPACE pg_default;

create index IF not exists idx_tbl_fitness_membery_price on public.tbl_fitness using btree (fit_price_membery) TABLESPACE pg_default;